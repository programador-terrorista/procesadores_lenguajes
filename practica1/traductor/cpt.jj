//*****************************************************************
// File:   cpt.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   enero 25
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(cpt)

package traductor;

//...

public class cpt {
   //...
   static public boolean verbose = false;
   public static void main(String[] args) {
	   
	   cpt parser = null;
	   
	   try {
		   if(args.length == 0) {
			   parser = new cpt(System.in);
		   }else {
				if (args.length == 2){
					verbose = true;
				}
			   	parser = new cpt(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
			
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (Exception e) {
			// Handle the exception
			System.err.println("An exception occurred: " + e.getMessage());
	   }
	}
}
PARSER_END(cpt)

TOKEN_MGR_DECLS :
{
	static void CommonTokenAction(Token t){
		if(cpt.verbose){
			System.out.println("(" + t.beginColumn + "," + t.beginLine + ")" + ":" + tokenImage[t.kind] + "\"" + t.image + "\"");
		}
	}
}

TOKEN : {
	< #LETTER: ["a"-"z","á","é","í","ó","ú"] >
|	< #DIGIT: ["0"-"9"] >
}

<DEFAULT> SKIP : {
	< tCOMENTARIO: ("--"(~["\n"])*["\n"]) >
|	" "
|	"\t"
|	"\n"
|	"\r" 
}

TOKEN : {
	< tVAR: "var" >
|	< tCOMA: [","] >
|	< tDOSPUNTOS: [":"]>
|	< tARRAY: "array">
|	< tOFOP: "of" > //tipo operador of
|	< tSIZEOP: "size">
|	< tWHENOP: "when">
|	< tDOOP: "do">
|	< tELSEWHENOP: "elsewhen">
|	< tELSEOP: "else">
|	< tLOOPOP: "loop"(" " | "\t")*"while">
|	< tDONE: "done">
|	< tNULL: "null">
|	< tABRE_PARENTESIS: ["("]>
|	< tCIERRA_PARENTESIS: [")"]>
|	< tABRE_CORCHETE: ["["]>
|	< tCIERRA_CORCHETE: ["]"]>
|	< tPROCEDIMIENTO: ("proc")>
|	< tFUNCION: "func">
|	< tIS: "is">
|	< tOUT: "out">
|	< tIN: "in">
|	< tINOUT: "inout">
|	< tRETURN: "return">
|	< tREAD: "read">
|	< tREADLN: "readln">
|	< tPRINT: "print">
|	< tPRINTLN: "println">
|	< tINT_TO_CHAR: "int2char">
|	< tCHAR_TO_INT: "char2int">
|	< tPUNTO_COMA: [";"]>
|	< tASIGNADOR: ["="]>
|	< tESCALAR: ("bool" | "char" | "int")>
|	< tLITERAL_NUMERO: (<DIGIT>)+ >
|	< tLITERAL_CARACTER: ("'"((~["\n","\t","\r"])| "\\n" | "\\t" | "\\r")"'") >
|	< tLITERAL_BOOLEANO: ("true" | "false")>
|	< tTERMINAR: "EXIT"> 
|	< tOPERADOR_ARITMETICO_SUMATIVO: ("+" | "-")>
|	< tOPERADOR_MULTIPLICATIVO: ("*" | "/" | "mod")>
|	< tOPERADOR_BOOLEANO: ("and" | "or")>
|	< tNOT: ("not")>
|	< tOPERADOR_RELACIONAL: (">" | ">=" | "<" | "<=" | "==" | "<>") >
|	< tFLECHA : ("->")>
|	< tIDENT: < LETTER >(< LETTER >|< DIGIT >|"_")*> // debe ir último, cambiar a upper en semántico o sintáctico

}

MORE : {
	<tABRE_COMILLA: "\"" > : ENTRE_COMILLAS
|	<noReconocido: ~[]> :ERROR
}

< ENTRE_COMILLAS > MORE:{
	<tTEXTO_STRING: ~["\""]>
|	<tDOBLE_COMILLA: "\"\"">{
		image.delete(image.length()-1,image.length());
	}
} 
< ENTRE_COMILLAS > TOKEN : {
	<tLITERAL_STRING:["\""]>{
		image.delete(0, 1);
		image.delete(image.length()-1,image.length());
		matchedToken.image = image.toString();
	}:DEFAULT
}



< ERROR > SPECIAL_TOKEN : {
	<"--">{
		System.out.println("ERROR LÉXICO: (" + SimpleCharStream.getBeginColumn() + "," + SimpleCharStream.getBeginLine() + ")" + ": " + "símbolo no reconocido" + ": " + "\"" + image + "\"");
	} :DEFAULT
|	<[" ","\t","\n","\r" ]> {
		System.out.println("ERROR LÉXICO: (" + SimpleCharStream.getBeginColumn() + "," + SimpleCharStream.getBeginLine() + ")" + ": " + "símbolo no reconocido" + ": " + "\"" + image + "\"");
	} :DEFAULT

}


<ERROR> MORE : {
	<~[]> :ERROR
}



//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa() : 
{}
{
	<tPROCEDIMIENTO>
	<tIDENT>
	<tIS>
	Cuerpo()
	<tDONE>
	<EOF>
}

void Cuerpo() : 
{}
{
	(DeclaraVar())*
	(DeclaraFunc() | DeclaraProc())*
	BloqueInstrucciones()
}

void DeclaraProc() : 
{}
{
	<tPROCEDIMIENTO>
	<tIDENT>
	Parametros()
	<tIS>
	Cuerpo()
	<tDONE>
}

void DeclaraFunc() :
{}
{ 
	<tFUNCION>
	<tIDENT>
	Parametros()
	<tFLECHA>
	<tESCALAR>
	<tIS>
	Cuerpo()
	<tDONE>
}

void Parametros() :
{}
{
	(
		<tABRE_PARENTESIS>
		( 
			(<tIN>|<tOUT>|<tINOUT>) ListIdent() <tDOSPUNTOS> ( ArrayCabecera()|<tESCALAR>)
			(<tCOMA> (<tIN>|<tOUT>|<tINOUT>) ListIdent() <tDOSPUNTOS> ( ArrayCabecera()|<tESCALAR>))* 
		)?
		<tCIERRA_PARENTESIS>
	)?
}

void ArrayCabecera() : 
{}
{
	<tARRAY>
	<tOFOP>
	<tESCALAR>
	<tSIZEOP>
	<tLITERAL_NUMERO>
}

void DeclaraVar() : 
{}
{
	<tVAR>
	( ListArray() | ListEscalar() ) 
	<tPUNTO_COMA>
}

void ListArray() : 
{}
{
	<tARRAY>
	ListIdent()
	<tOFOP>
	<tESCALAR>
	<tSIZEOP>
	<tLITERAL_NUMERO>

}

void ListEscalar() : 
{}
{
	ListIdent()
	<tDOSPUNTOS>
	<tESCALAR>
}

void ListIdent() : 
{}
{
	(<tIDENT>)(<tCOMA><tIDENT>)*
}

void BloqueInstrucciones() :
{}
{
	(Instruccion())*
}

void Instruccion() : 
{}
{
	Loop() 
|	When()
|	<tTERMINAR> <tPUNTO_COMA>
|	LOOKAHEAD(2)
	Asignacion() <tPUNTO_COMA>
|	Call() <tPUNTO_COMA>
|	Return() <tPUNTO_COMA>
| 	<tNULL> <tPUNTO_COMA>
}

void Asignacion() :
{}
{
	(<tIDENT> ( <tABRE_CORCHETE> Expresion() <tCIERRA_CORCHETE> )? )	 //comp. array
	<tASIGNADOR>
	Expresion()
}

void Loop() :
{}
{
	<tLOOPOP>
	Expresion()
	<tDOOP>
	BloqueInstrucciones()
	<tDONE>
	
}

void When() :
{}
{
	<tWHENOP>
	Expresion()
	<tDOOP>
	BloqueInstrucciones()
	
	(<tELSEWHENOP>
	Expresion()
	<tDOOP>
	BloqueInstrucciones() )*
	
	(<tELSEOP>
	BloqueInstrucciones() )?
	
	<tDONE>
	
}

void Call() :
{}
{
	(<tIDENT>|<tINT_TO_CHAR>|<tCHAR_TO_INT>|<tPRINT>|<tPRINTLN>|<tREAD>|<tREADLN>)
	<tABRE_PARENTESIS>
	(LOOKAHEAD(2) Expresion() (<tCOMA> Expresion())*)?
	<tCIERRA_PARENTESIS>
}

void Return() :
{}
{
	<tRETURN>
	Expresion()
}

void Expresion() :
{}
{
	Relacion() ( <tOPERADOR_BOOLEANO> Relacion() )* //devuelve bool si hay lo del paréntesis
}

void Relacion() :
{}
{
    ExpresionSimple() ( <tOPERADOR_RELACIONAL> ExpresionSimple() )? //devuelve bool si hay lo del paréntesis
}

void ExpresionSimple():
{}
{
    Termino() ( <tOPERADOR_ARITMETICO_SUMATIVO> Termino() )* // devuelve numero
}
void Termino():
{}
{
    Factor() ( <tOPERADOR_MULTIPLICATIVO> Factor() )* // devuelve numero
}
void Factor() :
{}
{	
    ( <tNOT> | <tOPERADOR_ARITMETICO_SUMATIVO> )? ( <tABRE_PARENTESIS> Expresion() <tCIERRA_PARENTESIS> | Primario() )
}

void Primario() :
{}
{	
	LOOKAHEAD(2)
	Call() //invoc a func.
|	LOOKAHEAD(2)
    <tIDENT> <tABRE_CORCHETE> Expresion() <tCIERRA_CORCHETE>	 //comp. array
|	<tIDENT>
|	<tLITERAL_CARACTER>
|	<tLITERAL_NUMERO>
|	<tLITERAL_BOOLEANO>
|	<tLITERAL_STRING>
}
